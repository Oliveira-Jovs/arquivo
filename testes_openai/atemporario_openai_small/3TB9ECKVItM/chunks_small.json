{
    "chunks": [
        "Olá, seja muito bem-vindos a mais uma aula no curso de linguagem de programação específica para IA. Hoje iremos explorar mais alguns conceitos de Scherlin. O caso do conceito de hoje será o Unroll. Como a gente viu naquele exemplo idático, com a geração de numeros de fibro nat, pode ser utilizado para diminuir o número de interações a custo do tamanho do corpo do loop. Então, vamos aumentar o corpo do loop para diminuir o número de interações. A gente viu que ele tem um efeito de como se executasse múltiplas interações em um a só no loop transformado. Ele pode ser útil para quando a gente tem pixels que manipulam dados em comunes e um padrão específico que a gente vai ver frequentemente, que às vezes é útil utilizar o Unroll quando a gente tem mais de um canal e quer se pre-executar o assine desses canais, certo? Em sequência, então, um atrás do outro sem uma criação de um novo loop. Ele tem duas sintaxes, a primeira delas é só passando um Avar para dentro desse Unroll e a outra Avar em um fator. Ele vai ser utilizado com um bound ou com um split. No caso aqui, quando a gente quer fazer um Unroll, por exemplo, de um Avar que não sejam os canais, a gente vai precisar fazer um split dessa Avar, certo? E a gente faz o split com um fator e depois aplica um Unroll nessa Avar que vai estar ali bem interna no alinhamento do loop, certo? Uma outra opção é você se preenfezar essa sintaxe aqui, Unroll, passando o Avar e depois o fator. A diferença é que você vai ficar escondido o split, certo? Ele vai esconder esse split. Para o exemplo dos canais, a gente vai estar utilizando esse bound aqui. Então, nós vamos, na verdade, utilizar tanto o Reorder como o bound para mover os canais para a parte mais interna do loop, certo? O bound, ele vai dizer para o realign que a minha variável do canal é limitada entre 0 e 3, certo? Então ali, RGB, sempre que vai trabalhar em realign, com o mínimo e o extente, que é a extensão daquela dimensão. Então, a gente vai passar para o bound, a variável, o mínimo que vai ser 0 e o extente que vai ser 3. Aqui são 3 canais. E a partir disso, diferentemente da sintaxe com o split, a gente sabe os limites que esse loop vai percorrer. A gente sabe qual é os limites da minha variável. Então, a gente utiliza o bound para passar essa informação para o Unroll depois. No caso, onde a gente não sabe a dimensão do looping, que vai ser, nos casos, que a gente tem uma variável que não seja aquela dos canais, por exemplo, a gente vai ter que estar utilizando essa sintaxe com o splitting. Iremos agora verificar na prática a utilização do Unroll. Eu tenho aqui um exemplo, onde eu estou aplicando um efeito 7m1, certo? Então, nós temos um efeito de falta antiga sendo aplicado. Primeiramente, mostrando o protótipo de Python para a gente ter um guia da temporização, certo, do runtime da pipeline. Eu vou rodar o protótipo aqui. E nós temos, em Python, a velocidade de 20, no caso ele está demorando 23 milissegundos, no caso 24 milissegundos, para completar a execução da pipeline na média. No pior caso, está em 46 milissegundos e, no melhor caso, 20 milissegundos. A pipeline é simples, ela só envolve multiplicar os canais da imagem por diversos fatores, certo? Cada canal novo, ele vai ter, com os 3 fatores associados a ele, certo? Cada novo canal da imagem, cada novo RGIB, é uma ponderação dos RGIB anteriores, iniciais. Após isso, eu faço uma merging desses canais, converto para a efeito 8, a versão clipada dele, ou seja, mantida ali entre zeros, que eu disse. Eu tenho aqui também um protótipo implementado em C++, com OpenCV. Então, é a nossa segunda referência de tempo, e nós esperamos um tempo pouco menor de execução em relação ao Python. Já o termos aqui, o resultado do OpenCV, está igualzinho ao do Python. E, no caso, a gente tem aqui 0,3 milissegundos na média, certo? Em comparação ao Python, com os seus 23 milissegundos. No melhor caso, a gente tem 0,19 milissegundos e no pior caso, 4 milissegundos. Então, está bem mais rápido que o Python. Vamos então ver se a gente consegue chegar mais rápido com o Relide. Então, eu tenho aqui para a plana implementada no Relide com Generator, e com um parâmetro aqui para selecionar o schedule customizado, certo? E, o que a gente tem aqui é esse MOOCs. E aí, no caso, a gente vai poder observar uma das maiores utilidades do Unroll, que é a eliminação do Select para fazer esse Assign dos canais. Então, a gente tem um MOOCs aqui e a gente consegue converter, ao invés de ter essa multiplexação, a gente vai converter isso aqui para executar o Assign um depois do outro ali dentro do loop mais interno da minha pipeline. Então, eu tenho aqui primeiro a utilização com o paralismo apenas sendo aplicado no Y, no e-sons da sem-mai. Então, nós vamos verificar, ainda sem o Unroll, certo? Uma aplicação mais simples de schedule. Ao executar isso aqui, a gente obtém um código bem mais rápido que o Python, mais lento que o OPCV. Inclusive, o melhor tempo dessa execução em Relide é assinando a média em relação ao OPCV, certo? Nós podemos, então, agora verificar o set-win-file, que eu tenho já carregado aqui, eu só preciso recarregar essa página. Vamos fechar o Assembly e verificar aqui que a gente tem esse MOOCs aqui dentro internamente no... A gente tem aqui o Y sendo executado em paralelo e dentro do X, a parte mais interna, a gente tem esse MOOCs aqui, certo? Então, vamos remover esse MOOCs. Como a gente viu nos islágeas, a gente tem que utilizar algumas diretivas junto do meu Unroll para poder ter o comportamento que nós esperamos. A primeira delas, como mencionado, é o Reorder. Nós precisamos mover os canais para a parte mais interna do loop, certo? A gente tem que garantir que eles estejam na parte mais interna do alinhamento de loop. Seguindo a isso, utilizamos um Bound para estabelecer os limites da minha VAR, que são os canais. E aí eu tenho o mínimo, que é 0 e a extensão dessa minha dimensão, que vai ser 3. Então, a gente vai de 0 até 2, 0, 1 e 2. E, seguindo isso, nós executamos o Unroll. Eu posso remover isso aqui para que a gente veja um efeito que pode ser observado quando vocês estiverem utilizando essas diretivas, certo? Então, ao rodar o caso 1... A gente tem ainda uma partidária um pouco mais lenta, inclusive. E ao verificar a atualização aqui do Statement File... Vou aumentar um pouco. Nós temos o seguinte... São 3 versões aqui da minha execução, certo? Uma para cada um daqueles canais. Então, é como se ele estivesse considerando o C, o canal, como o loop mais externo. E, no final,",
        "nós vamos executar o que o Lillian está fazendo com o padrão, com essa nossa partiline. Eu vou recarregar o meu Statement File. E, como esperado, o C, o canal está aqui no loop mais externo. Então, ao fazer o Unroll, a gente estabelece esse Extent aqui, com o Bound, certo? E, ao fazer o Unroll, o Reorder, ele vai desenrolar essa computação em 3 loops diferentes, certo? Então, 3 loops por toda imagem diferentes. Vamos, então, remover e passar a fazer o Unroll, junto com as duas outras diretivas. Ok, a gente tem um pouco mais rápido do que o nosso teste inicial, com aqueles 3 loops, certo? Mas, ainda, não tão rápido quanto o paralelo e também não tão rápido quanto o OpenCV. Vamos, então, prosseguir com o scheduling dessa pipeline, mas antes, passando para verificar a nova estrutura obtida no Statement File. Então, nós temos aqui que temos o loop mais externo, em meio de output, pelo Y, depois pelo X, e os 3 canais sendo feito o Assign em sequência, um a prois ou outro. E, vamos, então, passar para o caso 2, que é a aplicação do paralelismo após esse Unroll, certo? Dessa forma, com o Reorder e o Bound. Achemos agora um aumento na velocidade, em comparação, inclusive, a esquerda O0 aqui, onde a gente chegou a 0.29 milissegundos, com o OpenCV aqui, já na média, já atingindo um valor menor, certo? Inclusive, o pior caso também, já tem uma boa diferença. Nós podemos prosseguir com o nosso scheduling, né, fazendo, testando um splitting e executando o paralelismo a partir desse splitting do Y, certo? Então, em vez de paralelizar a var Y pura, a gente vai fazer um splitting nela antes de aplicar o paralelismo. E, novamente, como antes, eu estou utilizando o Vector Size, obtido com a função Natural Vector Size do Relay, como uma guia para minha experimentação. É só um valor que eu posso, rapidamente, experimentar vários fatores dele, como uma guia, certo? No caso aqui, eu estou multiplicando ele por 8. Então, nós vamos executar aqui o caso 3. Era um pouco mais lento que a versão anterior. A gente pode experimentar também modificar esse Vector Size, e ver se a gente obtém um tempo um pouco melhor. Ele está um pouco mais rápido, mas ainda assim não superou o nosso schedule 2. Nós iremos então observar o schedule 4, onde a gente encadeia o splitting com a Vectorização, certo? O paralelismo com a Vectorização. Nós executamos o nosso unroll, fazemos o splitting do Y, e aplicamos o paralelismo na variável mais grande. Vamos fazer a variável mais externa, e fazemos o splitting do X, e aplicamos a Vectorização na variável mais interna, certo? Obviamente, a gente pode experimentar com diversos fatores desse número, ou simplesmente variando manualmente os números, certo? Com isso, nós obtemos 0,1 milissegundos. Nós podemos então rodar novamente o Prototipim, de C++, como o OPCV. C++, e em comparação, nós temos a metade do tempo na média com o Relide. E aí, para observar o que acontece, você tenta executar essa mesma operação sem o unroll, certo? Eu tenho um caso 5 aqui. Então, sem o unroll, a gente consegue chegar abaixo do OPCV na média, certo? Mas não tão rápido quanto fazendo o unroll, inclusive é também no range de metade do tempo em relação a esse schedule sem o unroll. A gente pode testar também a reordenação, esse caso 5. E aí também, um pouco mais rápido, mas o melhor tempo está na mesma ordem do nosso schedule 4. Aqui na média, no caso. Então, nós aplicamos o unroll para tanto possibilitar algumas otimizações do nosso código, como também eliminar o moose dentro do loop mais interno para o nosso pipeline. Como ele te recomendara, eu deixo para vocês tanto a lição de scheduling do Relide, como também novamente o ponto entre Relide definições relacionadas às funks, certo? Que vai conter as definições do Relide, as duas definições do Relide, para o unroll. Muito obrigado pela atenção de vocês e até a próxima."
    ]
}