1
00:00:00,000 --> 00:00:07,000
Olá, seja muito bem-vindos a mais uma aula do curso de linguagem de programação específica para iar.

2
00:00:07,000 --> 00:00:12,000
Hoje, podemos esforar mais alguns conceitos de Skylin.

3
00:00:12,000 --> 00:00:15,000
O caso o conceito de hoje será o un roll.

4
00:00:15,000 --> 00:00:22,000
Como a gente viu naquele exemplo idático com a geração de linguagem de fibonate,

5
00:00:22,000 --> 00:00:29,000
pode ser utilizado para diminuir o número de terações a custa do tamanho do corpo do loop.

6
00:00:29,000 --> 00:00:32,000
Nós vamos aumentar o corpo do loop.

7
00:00:32,000 --> 00:00:35,000
Afinal, o número de terações.

8
00:00:35,000 --> 00:00:49,000
A gente pode ver o que ele tem um efeito de como se executassem multiple terações em o que seria uma só no loop transformado.

9
00:00:49,000 --> 00:00:54,000
Ele pode ser útil para quando a gente tem pixels que manipulam dados em comuns.

10
00:00:54,000 --> 00:01:02,000
Um padrão específico que a gente vai ver frequentemente que, às vezes, é útil utilizar o roll.

11
00:01:02,000 --> 00:01:09,000
É quando a gente tem mais de um canal e quer se pertence a reputar o oceine desses canais, certo?

12
00:01:09,000 --> 00:01:14,000
Em sequência, então, um atragem de outro sem uma criação de um novo loop.

13
00:01:14,000 --> 00:01:21,000
Ele tem duas sintaxis. A primeira delas é só baçando um avar para dentro desse um roll.

14
00:01:21,000 --> 00:01:24,000
E a outra avar é um fator.

15
00:01:24,000 --> 00:01:28,000
Ele vai ser utilizado com um bound e com split.

16
00:01:28,000 --> 00:01:35,000
No caso aqui, quando a gente quer fazer um roll, por exemplo, de um avar que não seja os canais,

17
00:01:35,000 --> 00:01:40,000
a gente normalmente precisa fazer um split dessa avar, certo?

18
00:01:40,000 --> 00:01:50,000
E a gente faz um split com um fator e depois aplica um roll nessa avar, que vai estar ali bem interna no alinhamento do loop, certo?

19
00:01:50,000 --> 00:01:58,000
Uma outra opção é você se perdi fazer esse sintaxis aqui em roll passando o var e depois o fator.

20
00:01:58,000 --> 00:02:10,000
A diferença que você vai ficar escondido o split, certo? Ele vai esconder esse split.

21
00:02:10,000 --> 00:02:15,000
Para o exemplo dos canais, a gente vai estar utilizando esse bound aqui.

22
00:02:15,000 --> 00:02:25,000
Então, nós vamos, na verdade, utilizar tanto o reward como o bound para mover os canais, para a parte mais interna do loop, certo?

23
00:02:25,000 --> 00:02:33,000
O bound vai dizer por relied que a minha variável do canal é limitada entre 0 a 3, certo?

24
00:02:33,000 --> 00:02:40,000
Então, a gente sempre vai trabalhar em relied com o mínimo e o extente, que é o roll.

25
00:02:40,000 --> 00:02:42,000
A extensão daquela dimensão.

26
00:02:42,000 --> 00:02:51,000
Então, a gente vai passar para o bound a variável, o mínimo que vai ser 0 e o extente que vai ser 3, que são 3 canais.

27
00:02:51,000 --> 00:03:00,000
E a partir disso, definitivamente das taxas ali com o split, a gente sabe os limites que este do que vai percorrer.

28
00:03:00,000 --> 00:03:07,000
A gente sabe qual é os limites da minha variável. Então, a gente tem o utiliz o bound para passar essa informação para o roll depois.

29
00:03:07,000 --> 00:03:20,000
No caso onde a gente não sabe a dimensão do loop, que vai ser nos casos, a gente tem uma variável que não seja aquela da escanais, por exemplo, a gente vai estar utilizando essa sintaxis com o splitting.

30
00:03:21,000 --> 00:03:26,000
Eremos agora verificar na prática a utilização do roll.

31
00:03:26,000 --> 00:03:36,000
Eu tenho aqui um exemplo onde eu estou aplicando um efeito 7 em uma imagem, certo? Então nós temos um efeito de falta antiga sendo aplicado.

32
00:03:37,000 --> 00:03:44,000
Primeiramente, mostrando o protótipo de Python para a gente ter um dia da temporização, certo?

33
00:03:44,000 --> 00:03:50,000
Do runtime dessa pipeline, eu vou rodar o protótipo aqui.

34
00:03:58,000 --> 00:04:01,000
E nós temos em Python.

35
00:04:02,000 --> 00:04:20,000
A velocidade dele de 20, no caso ele está demorando 23 mil segundos, no caso 24 mil segundos para completar a execução da pipeline na média, no pior caso, está em 46 mil segundos e no melhor caso 20 mil segundos.

36
00:04:21,000 --> 00:04:24,000
A pipeline ela é simples, ela só envolve.

37
00:04:24,000 --> 00:04:35,000
Multiplicar os canais da imagem por diversos fatores, certo? Cada canal novo ele vai ter constit 3 fatores associados a ele, certo?

38
00:04:35,000 --> 00:04:43,000
Então cada novo canal da minha imagem, cada novo RGB, é uma ponderação dos RGB anteriores, né? A Iniciais.

39
00:04:44,000 --> 00:04:55,000
Após isso eu faço merge nesses canais, converto para a efeito a versão clipada dele, ou seja, a mantida entre 0 e 0, 3 e 5.

40
00:04:57,000 --> 00:05:02,000
Eu tenho aqui também um protótipo, então eu estou em também estar de ser mais mais com o OpenCV.

41
00:05:02,000 --> 00:05:17,000
Então, é a nossa segunda referência de tempo e nós esperamos um tempo pouco menor de execução em relação ao Python.

42
00:05:33,000 --> 00:05:48,000
Já o que temos aqui, o resultado do OpenCV está igualzinho ao do Python e no caso a gente tem aqui 0,3 mil segundos na média, certo?

43
00:05:48,000 --> 00:06:00,000
Em comparação ao Python, com seus 23 mil segundos. No maior caso a gente tem 0,19 mil segundos e não pior caso 4 mil segundos.

44
00:06:01,000 --> 00:06:08,000
Então, é bem mais rápido que o Python. Vamos ver se a gente consegue chegar mais rápido com o ReliR.

45
00:06:12,000 --> 00:06:22,000
Então, eu tenho aqui para falar implementada no ReliR com um generator e com um parâmetro para selecionar o Skydoll somizado, certo?

46
00:06:23,000 --> 00:06:43,000
E aí, o que a gente tem aqui é esse Mox. E aí, no caso a gente vai poder observar um das maiores utilidades do Unroll, que é a eliminação do Select para fazer esse a-sign dos canais.

47
00:06:44,000 --> 00:06:50,000
Então, a gente tem um Mox aqui e a gente consegue converter a gente de...

48
00:06:50,000 --> 00:07:01,000
Essa multiplação é só convertir isso daqui para executar o a-sign um depor de outro ali dentro do loop mais interno da minha empatulaire.

49
00:07:04,000 --> 00:07:12,000
Então, eu tenho aqui primeiro a utilização com o paranelismo apenas sendo aplicado no IPSON.

50
00:07:13,000 --> 00:07:20,000
Então, nós vamos verificar ainda sem o Unroll, certo? Uma aplicação mais simples de Skydoll.

51
00:07:20,000 --> 00:07:44,000
A executa isso aqui, a gente obtém um código também bem mais rápido que o Python mais lento que o OPCV, inclusive o melhor tempo dessa execução.

52
00:07:45,000 --> 00:07:54,000
Em Relight, está a simenda médio em relação ao OPCV, certo?

53
00:07:55,000 --> 00:08:08,000
Nós podemos, então, agora verificar o Setum File, que eu tenho já canegado aqui, só preciso carregar essa página.

54
00:08:08,000 --> 00:08:18,000
Vamos fechar o Assemble e verificar aqui, naqueles que a gente tem esse Mox aqui dentro internamente no...

55
00:08:19,000 --> 00:08:27,000
A gente tem que o OPCV não se conectar em paralelo e dentro do Nox, né?

56
00:08:27,000 --> 00:08:32,000
Pato mais interno a gente tem esse Mox aqui, certo?

57
00:08:33,000 --> 00:08:52,000
Então, vamos remover esse Mox. Como as devils, as devils, a gente tem que utilizar algumas diretivas junto do meu Unroll para poder ter o comportamento que nós esperamos.

58
00:08:53,000 --> 00:09:01,000
A primeira delas, como mencionada, é o Reorder. Nós precisamos mover os canais para a parte mais interna do loop, certo?

59
00:09:01,000 --> 00:09:07,000
A gente tem que garantir que eles tejam na parte mais interna do aninhamento do loop.

60
00:09:07,000 --> 00:09:16,000
O seguinte é isso, utilizamos um Bound para estabelecer os limites do da minha VAR, que é o channel.

61
00:09:16,000 --> 00:09:26,000
E aí, eu tenho o mínimo que é zero e a extensão dessa minha dimensão, que vai ser o 3, então, a gente vai dizer zero até 2, zero com 1 e 2.

62
00:09:27,000 --> 00:09:42,000
E, seguinted é isso, nós executamos o Unroll. Eu posso remover isso aqui, porque a gente veja um efeito que pode ser observado quando vocês tiverem utilizando saídendetivas, certo?

63
00:09:42,000 --> 00:09:55,000
Então, ao rodar o caso um, a gente tem ainda um apapelá, um pouco mais interinclusive.

64
00:09:57,000 --> 00:10:08,000
E ao verificar a atualização do Statement File, vamos tentar um pouco.

65
00:10:13,000 --> 00:10:22,000
Nós temos o seguinte, três versões aqui do Amp da minha execução, certo?

66
00:10:22,000 --> 00:10:32,000
Então, é como se o canal era considerado o C, o canal como o loop mais externo.

67
00:10:33,000 --> 00:10:58,000
Então, nós vamos fazer o que o leilá está fazendo com o padrão com essa nossa patilá.

68
00:10:59,000 --> 00:11:05,000
Eu vou recarregar o meu Statement File.

69
00:11:07,000 --> 00:11:22,000
E como esperado o C, o canal está aqui no loop mais externo. Então, ao fazer o Unroll, a gente estabelece esse extente aqui, com o bão, certo?

70
00:11:23,000 --> 00:11:30,000
E ao fazer o Unroll, sim, o Reorder, ele vai desenrolar essa computação em três grupos diferentes, certo?

71
00:11:30,000 --> 00:11:38,000
Então, três grupos por toda a imagem diferente.

72
00:11:38,000 --> 00:11:47,000
Vamos então remover e passar a fazer o Unroll junto com as duas outras objetivas.

73
00:11:48,000 --> 00:12:07,000
Ok, a gente tem um pouco mais rápido que o nosso teste lá inicial com aqueles três dupe, certo?

74
00:12:08,000 --> 00:12:13,000
Mas ainda não estão rápido contra o paralelo e também não com o rápido contra o OpenCV.

75
00:12:14,000 --> 00:12:26,000
Vamos então procedir com o scheduling dessa papilá, mas antes passando para verificar a nova estrutura obtida no Statement File.

76
00:12:27,000 --> 00:12:42,000
Então, nós temos aqui que temos o loop mais externo em média o tipo de Pell X, depois pelo X, e os três canais sendo feito o assigned em sequência, uma prois ou outra.

77
00:12:43,000 --> 00:12:57,000
E vamos então passar para o caso dois, que é a aplicação do paralelismo após esse Unroll, certo?

78
00:13:58,000 --> 00:14:09,000
E, novamente, como antes, estou utilizando o Vector Size, obtido com a função Natural Vector Size do Relage, como a dia para mim, experimentação.

79
00:14:09,000 --> 00:14:17,000
Ele falou um valor que eu posso rapidamente experimentar vários fatores dele, como uma guia, certo?

80
00:14:17,000 --> 00:14:19,000
O caso aqui estou explicando ele por 8.

81
00:14:20,000 --> 00:14:25,000
Então, nós vamos executar aqui o caso 3.

82
00:14:32,000 --> 00:14:36,000
Era um pouco mais lento que a versão de Rewo.

83
00:14:37,000 --> 00:14:49,000
Pode experimentar, então, em modificar esse Vector Size, que o que temos é um tempo um pouco melhor.

84
00:14:53,000 --> 00:14:58,000
Então, um pouco mais rápido, mas ainda assim, não superou nosso Skyroll 2.

85
00:14:59,000 --> 00:15:08,000
Nós vamos observar o Skyroll 4, onde a gente encadeia o Splitting com a virtualização, certo? Paralelismo com a virtualização.

86
00:15:08,000 --> 00:15:27,000
Nós executamos o Unroll, fazemos o Splitting do Ipsum, e aplicamos o Paralelismo na variável mais externa, e fazemos o Splitting do X, e aplicamos a virtualização na variável mais interna, certo?

87
00:15:29,000 --> 00:15:37,000
Alguém, a gente pode experimentar com diversos fatores desse número, você pode variar os números, certo?

88
00:15:37,000 --> 00:15:59,000
Com isso nós obtemos 0,1 ms, nós podemos então rodar novamente o Prototpinho, ser mais e mais, como eu percebe.

89
00:16:08,000 --> 00:16:19,000
E, em comparação, nós temos metade do tempo na média com o Relide.

90
00:16:19,000 --> 00:16:40,000
E, para observar, o que acontece, se você tenta executar essa mesma operação sem o Unroll, certo? Eu tenho um caso 5 aqui.

91
00:16:50,000 --> 00:17:11,000
Então, sem o Unroll, a gente consegue chegar a baixo do OpenCV na média, certo? Mas não tão rápido quanto fazendo o Unroll, inclusive, também ali no range de metade do tempo em relação a esse Skyroll sem o Unroll.

92
00:17:12,000 --> 00:17:20,000
A gente pode ter xato também a reordinação, esse caso 5.

93
00:17:20,000 --> 00:17:41,000
E, também, um pouco mais rápido, mas o melhor tempo está na mesma ordem ali do nosso Skyroll 4.

94
00:17:42,000 --> 00:17:49,000
E, na média, no caso.

95
00:17:50,000 --> 00:18:05,000
Então, nós aplicamos o Unroll para tanto possibilitar algumas optimizações do nosso código, como também eliminar o Moops dentro do Loops mais interno para a sua pipeline.

96
00:18:06,000 --> 00:18:20,000
Como o leite vai recomendar, eu deixo para vocês tanto a lição de Skyroll em do Relide, como também, novamente o ponto em de Relide definia definições relacionadas às FUNCES, certo?

97
00:18:20,000 --> 00:18:29,000
Que vai contê as definições do Relide, as duas definições do Relide para o Unroll.

98
00:18:29,000 --> 00:18:33,000
Muito obrigado pela atenção de vocês e até a próxima.

