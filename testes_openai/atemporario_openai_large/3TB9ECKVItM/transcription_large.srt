1
00:00:00,000 --> 00:00:06,680
Olá, sejam muito bem-vindos a mais uma aula do curso de linguagem de programação específica para IA.

2
00:00:08,000 --> 00:00:11,780
Hoje iremos explorar mais alguns conceitos de scheduling.

3
00:00:12,620 --> 00:00:15,040
O caso conceito de hoje será o unroll.

4
00:00:15,780 --> 00:00:22,200
Ele, como a gente viu naquele exemplo didático com a geração de números de Fibonacci,

5
00:00:22,200 --> 00:00:29,540
pode ser utilizado para diminuir o número de iterações a custo do tamanho do corpo do loop.

6
00:00:29,740 --> 00:00:34,540
Então nós vamos aumentar o corpo do loop a fim de diminuir o número de iterações.

7
00:00:35,440 --> 00:00:48,680
A gente viu que ele tem o efeito de como se executasse múltiplas iterações em o que seria uma só no loop transformado.

8
00:00:49,680 --> 00:00:52,180
Ele pode ser útil para quando a gente tem pixels.

9
00:00:52,200 --> 00:00:53,800
Ou seja, para os criadores que manipulam dados incomuns.

10
00:00:54,620 --> 00:01:02,080
E um padrão específico que a gente vai ver frequentemente, que às vezes é útil utilizar o unroll,

11
00:01:02,620 --> 00:01:09,700
é quando a gente tem mais de um canal e quer sempre executar o assign desses canais em sequência.

12
00:01:09,820 --> 00:01:13,180
Então um atrás do outro sem uma criação de um novo loop.

13
00:01:14,560 --> 00:01:21,260
Ele tem duas sintaxes. A primeira delas é só passando uma var para dentro desse unroll.

14
00:01:21,260 --> 00:01:22,180
E a outra...

15
00:01:22,200 --> 00:01:23,680
A var e um fator.

16
00:01:24,680 --> 00:01:27,320
Ele vai ser utilizado com bound ou com split.

17
00:01:27,760 --> 00:01:35,000
No caso aqui, quando a gente quer fazer um unroll, por exemplo, de uma var que não sejam esses canais,

18
00:01:35,740 --> 00:01:39,260
a gente normalmente precisa fazer um split dessa var.

19
00:01:39,800 --> 00:01:49,160
E a gente faz o split com o fator e depois aplica um unroll nessa var que vai estar ali bem interna no alinhamento do loop.

20
00:01:49,160 --> 00:01:49,880
Certo?

21
00:01:50,620 --> 00:01:52,000
Uma outra opção.

22
00:01:52,200 --> 00:01:57,860
É você simplesmente fazer essa sintaxe aqui, unroll, passando var e depois o fator.

23
00:01:58,680 --> 00:02:06,140
A diferença é que você vai ficar escondido o split, certo?

24
00:02:06,520 --> 00:02:07,860
Ele vai esconder esse split.

25
00:02:10,120 --> 00:02:14,280
Para o exemplo dos canais, o que a gente vai estar utilizando é esse bound aqui.

26
00:02:14,900 --> 00:02:18,620
Então nós vamos, na verdade, utilizar tanto o reorder como o bound.

27
00:02:18,620 --> 00:02:21,180
Para mover os canais.

28
00:02:21,400 --> 00:02:21,720
Para...

29
00:02:21,720 --> 00:02:24,140
Para a parte mais interna do loop.

30
00:02:24,740 --> 00:02:25,140
Certo?

31
00:02:25,540 --> 00:02:32,460
O bound vai dizer para o relay que a minha variável do canal é limitada entre 0 a 3.

32
00:02:32,560 --> 00:02:32,800
Certo?

33
00:02:32,900 --> 00:02:34,000
Então ali, RGB.

34
00:02:34,360 --> 00:02:38,020
A gente sempre vai trabalhar em relay com o mínimo e o extent.

35
00:02:38,240 --> 00:02:42,140
Que é a extensão daquela dimensão.

36
00:02:42,540 --> 00:02:48,320
Então a gente vai passar para o bound a variável, o mínimo que vai ser 0 e o extent que vai ser 3.

37
00:02:48,320 --> 00:02:49,420
E aqui são 3 canais.

38
00:02:51,720 --> 00:03:00,100
E a partir disso, diferentemente da sintaxe com o split, a gente sabe os limites que esse loop vai percorrer.

39
00:03:00,100 --> 00:03:02,100
A gente sabe quais os limites da minha variável.

40
00:03:02,100 --> 00:03:07,540
Então a gente utiliza o bound para passar essa informação para o unroll depois.

41
00:03:07,540 --> 00:03:16,040
No caso onde a gente não sabe a dimensão do loop, que vai ser nos casos onde a gente tem uma variável que não seja aquela dos canais, por exemplo.

42
00:03:16,040 --> 00:03:20,240
A gente vai ter que estar utilizando essa sintaxe com o splitting.

43
00:03:21,720 --> 00:03:25,720
E vamos verificar na prática a utilização do unroll.

44
00:03:25,720 --> 00:03:31,300
Eu tenho aqui um exemplo onde eu estou aplicando um efeito sepia em uma imagem.

45
00:03:31,300 --> 00:03:31,800
Certo?

46
00:03:31,800 --> 00:03:36,400
Então nós temos um efeito de foto antiga sendo aplicado.

47
00:03:36,400 --> 00:03:44,140
Primeiramente mostrando um protótipo em Python para a gente ter um guia da temporização, certo?

48
00:03:44,140 --> 00:03:46,840
Do runtime dessa pipeline.

49
00:03:46,840 --> 00:03:49,840
Eu vou rodar o protótipo aqui.

50
00:03:51,720 --> 00:04:14,640
E nós temos em Python a velocidade de 20, no caso ele está demorando 23 milissegundos, no caso 24 milissegundos para completar a execução da pipeline na média.

51
00:04:14,640 --> 00:04:20,100
No pior caso está em 46 milissegundos e no melhor caso 20 milissegundos.

52
00:04:20,100 --> 00:04:21,720
A pipeline é simples.

53
00:04:21,720 --> 00:04:28,720
Ela só envolve multiplicar os canais da imagem por diversos fatores, certo?

54
00:04:28,720 --> 00:04:34,720
Cada canal novo vai ter um conjunto de 3 fatores associados a ele, certo?

55
00:04:34,720 --> 00:04:42,720
Então cada novo canal da minha imagem, cada novo RGB é uma ponderação dos RGB anteriores, iniciais.

56
00:04:42,720 --> 00:04:46,720
Após isso eu faço o merging desses canais.

57
00:04:46,720 --> 00:04:48,720
Converto para a Uint8 a versão clipada dele.

58
00:04:48,720 --> 00:04:49,720
E depois eu faço o merging desses canais.

59
00:04:49,720 --> 00:04:50,720
Converto para a Uint8 a versão clipada dele.

60
00:04:50,720 --> 00:04:51,720
E depois eu faço o merging desses canais.

61
00:04:51,720 --> 00:04:52,720
Converto para a Uint8 a versão clipada dele.

62
00:04:52,720 --> 00:04:53,720
Ou seja, mantido ali entre 0 e 55.

63
00:04:53,720 --> 00:04:54,720
Ou seja, mantido ali entre 0 e 55.

64
00:04:54,720 --> 00:04:58,720
Eu tenho aqui também um protótipo implementado em C++ com OpenCV.

65
00:04:58,720 --> 00:05:03,720
Eu tenho aqui também um protótipo implementado em C++ com OpenCV.

66
00:05:03,720 --> 00:05:08,720
Então é a nossa segunda referência de tempo.

67
00:05:08,720 --> 00:05:18,720
E nós esperamos um tempo um pouco menor de execução em relação ao Python.

68
00:05:18,720 --> 00:05:20,720
E nós esperamos um tempo um pouco menor de execução em relação ao Python.

69
00:05:20,720 --> 00:05:32,720
Então é a nossa segunda referência de tempo.

70
00:05:33,720 --> 00:05:38,720
Já obtemos aqui o resultado do OpenCV.

71
00:05:38,720 --> 00:05:39,720
Esta igual ao Python.

72
00:05:39,720 --> 00:05:48,720
E no caso a gente tem aqui 0,3 ms que está na média, certo.

73
00:05:48,720 --> 00:05:49,720
Em comparação ao Python.

74
00:05:49,720 --> 00:06:00,400
Python com seus 23 milissegundos. No melhor caso ele tem 0.19 milissegundos e no pior caso 4 milissegundos.

75
00:06:00,400 --> 00:06:08,020
Certo? Então ele vai bem mais rápido que o Python. Vamos então ver se a gente consegue chegar mais rápido com o RayLight.

76
00:06:08,020 --> 00:06:21,840
Então eu tenho aqui a Pipeline implementada no RayLight com o Generator e com um parâmetro aqui para selecionar o Schedule customizado.

77
00:06:21,840 --> 00:06:37,840
Certo? E aí o que a gente tem aqui é esse Mux e aí no caso a gente vai poder observar uma das maiores utilidades do Amplifier.

78
00:06:38,020 --> 00:06:43,360
Que é a eliminação do Select para fazer esse Assign dos canais.

79
00:06:43,360 --> 00:06:52,160
Certo? Então a gente tem um Mux aqui e a gente consegue converter essa multiplexação.

80
00:06:52,160 --> 00:07:00,840
A gente vai converter isso daqui para executar o Assign um depois do outro ali dentro do loop mais interno da minha Pipeline.

81
00:07:03,840 --> 00:07:07,360
Então eu tenho aqui primeiro a utilização.

82
00:07:07,360 --> 00:07:07,460
Certo?

83
00:07:08,020 --> 00:07:12,040
Com o paralelismo apenas sendo aplicado no Y dessa imagem.

84
00:07:13,040 --> 00:07:16,540
Então nós vamos verificar ainda sem o Unroll.

85
00:07:16,720 --> 00:07:19,900
Certo? Uma aplicação mais simples de Skylog.

86
00:07:31,800 --> 00:07:36,280
Ao executar isso aqui a gente obtém um código também bem mais rápido que o Python.

87
00:07:36,280 --> 00:07:37,940
Mas mais lento.

88
00:07:38,020 --> 00:07:41,080
Que o OpenCV.

89
00:07:41,300 --> 00:07:47,020
Inclusive o melhor tempo dessa execução em RayLight é...

90
00:07:47,020 --> 00:07:53,880
Está assinando a média em relação ao OpenCV.

91
00:07:54,040 --> 00:07:54,180
Certo?

92
00:08:00,900 --> 00:08:05,120
Nós podemos então agora verificar o StateWinFile.

93
00:08:05,120 --> 00:08:06,320
Que eu tenho já carregado aqui.

94
00:08:06,460 --> 00:08:08,000
Eu só preciso recarregar essa página.

95
00:08:08,020 --> 00:08:10,400
Vamos fechar o Assembly.

96
00:08:12,720 --> 00:08:16,420
E verificar aqui que a gente tem esse Mux aqui dentro.

97
00:08:17,000 --> 00:08:18,020
Internamente no...

98
00:08:20,380 --> 00:08:23,880
A gente tem aqui o Y sendo executado em paralelo.

99
00:08:25,680 --> 00:08:30,940
E dentro do X, na parte mais interna, a gente tem esse Mux aqui.

100
00:08:31,860 --> 00:08:32,200
Certo?

101
00:08:38,020 --> 00:08:42,900
Então vamos remover esse Mux.

102
00:08:43,920 --> 00:08:49,500
Como a gente viu nos slides, a gente tem que utilizar algumas diretivas junto do meu Unroll.

103
00:08:49,720 --> 00:08:52,380
Para poder ter o comportamento que nós esperamos.

104
00:08:52,960 --> 00:08:55,080
A primeira delas, como mencionado, é o Reorder.

105
00:08:55,280 --> 00:09:00,720
Nós precisamos mover os canais para a parte mais interna do loop.

106
00:09:00,720 --> 00:09:06,200
Certo? A gente tem que garantir que eles estejam na parte mais interna do alinhamento de loops.

107
00:09:07,140 --> 00:09:08,000
Seguinte aí.

108
00:09:08,000 --> 00:09:09,840
Para isso, utilizamos o Bound.

109
00:09:10,360 --> 00:09:14,360
Para estabelecer os limites da minha VAR.

110
00:09:14,680 --> 00:09:15,840
Que é os canais.

111
00:09:16,440 --> 00:09:18,040
E aí eu tenho o mínimo, que é 0.

112
00:09:18,320 --> 00:09:21,780
E a extensão dessa minha dimensão, que vai ser o 3.

113
00:09:21,960 --> 00:09:23,860
Então a gente vai de 0 até 2.

114
00:09:24,000 --> 00:09:25,060
0, 1 e 2.

115
00:09:26,540 --> 00:09:29,860
E seguinte a isso, nós executamos o Unroll.

116
00:09:30,340 --> 00:09:33,260
Eu posso remover isso aqui.

117
00:09:33,260 --> 00:09:37,240
Para que a gente veja um efeito que pode ser observado.

118
00:09:37,400 --> 00:09:37,900
Quando você estiver...

119
00:09:37,900 --> 00:09:40,660
Utilizando essas diretivas.

120
00:09:40,660 --> 00:09:41,660
Certo?

121
00:09:41,660 --> 00:09:44,660
Então ao rodar o caso 1.

122
00:09:51,660 --> 00:09:55,660
A gente tem ainda uma pipeline um pouco mais lenta inclusive.

123
00:09:56,660 --> 00:10:02,660
E ao verificar a atualização aqui do Statement File.

124
00:10:05,900 --> 00:10:07,300
Vou aumentar um pouco.

125
00:10:07,900 --> 00:10:15,060
E aí nós temos o seguinte.

126
00:10:15,060 --> 00:10:18,000
São três versões aqui.

127
00:10:18,000 --> 00:10:21,700
Da minha execução, certo?

128
00:10:21,700 --> 00:10:23,820
Uma para cada um daqueles canais.

129
00:10:23,820 --> 00:10:31,960
Então é como se o relator estivesse considerando o canal como o loop mais externo.

130
00:10:31,960 --> 00:10:32,740
.

131
00:10:32,740 --> 00:10:33,340
.

132
00:10:33,340 --> 00:10:34,120
.

133
00:10:34,120 --> 00:10:34,900
.

134
00:10:34,900 --> 00:10:35,520
.

135
00:10:35,520 --> 00:10:36,160
.

136
00:10:36,160 --> 00:10:36,920
.

137
00:10:36,920 --> 00:10:37,460
.

138
00:10:37,460 --> 00:10:38,460
.

139
00:10:38,460 --> 00:10:38,840
.

140
00:10:38,840 --> 00:10:46,840
.

141
00:10:50,080 --> 00:10:53,040
Estamos executando agora com um computeroot.

142
00:10:53,880 --> 00:10:55,180
Pra ver o que ele está fazendo.

143
00:10:55,180 --> 00:10:57,040
Por padrão.

144
00:10:57,040 --> 00:10:58,680
Com essa nossa pipeline.

145
00:10:59,680 --> 00:11:01,440
Eu vou recarregar o meu Statement File.

146
00:11:01,440 --> 00:11:02,500
O meu Statement File.

147
00:11:02,500 --> 00:11:03,500
.

148
00:11:04,000 --> 00:11:04,400
.

149
00:11:04,400 --> 00:11:05,220
.

150
00:11:05,220 --> 00:11:05,500
.

151
00:11:05,500 --> 00:11:06,400
.

152
00:11:06,400 --> 00:11:06,560
.

153
00:11:06,560 --> 00:11:07,020
.

154
00:11:07,020 --> 00:11:13,640
E como esperado, o canal está aqui no loop mais externo.

155
00:11:14,260 --> 00:11:22,260
Então ao fazer o unroll, a gente estabelece esse extent aqui com o bound, certo?

156
00:11:22,440 --> 00:11:29,300
E ao fazer o unroll sem o reorder, ele vai desenrolar essa computação em três loops diferentes.

157
00:11:29,300 --> 00:11:32,680
Então três loops por toda a imagem diferentes.

158
00:11:37,020 --> 00:11:45,800
Vamos então remover e passar a fazer o reorder junto com as duas outras diretivas.

159
00:11:55,980 --> 00:12:06,880
Ok, a gente tem um pouco mais rápido do que o nosso teste inicial com aqueles três loops.

160
00:12:07,020 --> 00:12:07,200
Certo?

161
00:12:07,980 --> 00:12:12,900
Mas ainda não tão rápido quanto o paralelo e também não tão rápido quanto o OpenCV.

162
00:12:13,600 --> 00:12:17,620
Vamos então prosseguir com o scheduling dessa pipeline.

163
00:12:18,200 --> 00:12:25,680
Mas antes, passando para verificar a nova estrutura obtida no statement file.

164
00:12:28,740 --> 00:12:36,620
Então nós temos aqui que temos o loop mais externo, image output pelo Y, depois pelo X.

165
00:12:37,020 --> 00:12:41,680
E os três canais sendo feito o assign em sequência, um após o outro.

166
00:12:49,100 --> 00:12:56,220
Iremos então passar para o caso 2, que é a aplicação do paralelismo após esse unroll.

167
00:12:56,740 --> 00:13:00,480
Certo? Dessa forma com o reorder e o bounding.

168
00:13:07,020 --> 00:13:08,060
Certo?

169
00:13:08,060 --> 00:13:11,120
Mais Certificado com a úmida bakery também pode substituir a opçãokelnar,

170
00:13:11,120 --> 00:13:25,680
muito menos com a sua categoria não permitímos que novamente tenha de roads e

171
00:13:25,680 --> 00:13:31,400
Jewels em que é o EXTERNO douyor que já tem nghĩ.

172
00:13:31,400 --> 00:13:32,460
0.50mS.

173
00:13:32,460 --> 00:13:34,140
Assim conosco termina seus testes.

174
00:13:34,140 --> 00:13:35,260
Ahtará também um unبلiness.

175
00:13:35,260 --> 00:13:35,600
A third step.

176
00:13:35,600 --> 00:13:48,740
nós podemos prosseguir com o nosso scheduling testando um splitting e executando o paralelismo

177
00:13:48,740 --> 00:13:54,920
a partir desse splitting do y. Então ao invés de paralelizar a var y pura, a gente vai fazer

178
00:13:54,920 --> 00:14:01,100
um splitting nela antes de aplicar o paralelismo. E novamente como antes eu estou utilizando o vector

179
00:14:01,100 --> 00:14:09,740
size obtido com a função naturalVectorSize do RayLight como uma guia para minha experimentação.

180
00:14:09,740 --> 00:14:16,600
Ele é só um valor que eu posso rapidamente experimentar vários fatores dele como uma guia,

181
00:14:16,600 --> 00:14:25,040
certo? No caso aqui eu estou multiplicando ele por 8. Então nós vamos executar aqui o caso 3.

182
00:14:31,100 --> 00:14:42,560
Ele é um pouco mais lento que a versão anterior. A gente pode experimentar também modificar esse

183
00:14:42,560 --> 00:14:55,100
vector size e ver se a gente obtém um tempo um pouco melhor. Ele está um pouco mais rápido,

184
00:14:55,100 --> 00:15:01,080
mas ainda assim não superou o nosso schedule 2. Nós iremos então observar o schedule 4,

185
00:15:01,080 --> 00:15:07,260
onde a gente encadeia o splitting com a vectorização, certo? O paralelismo com a

186
00:15:07,260 --> 00:15:17,580
vectorização. Nós executamos o nosso unroll, fazemos o splitting do y e aplicamos o paralelismo

187
00:15:17,580 --> 00:15:26,320
na variável mais externa e fazemos o splitting do x e aplicamos a vectorização na variável mais

188
00:15:26,320 --> 00:15:30,960
interna, certo? Normalmente a gente pode experimentar

189
00:15:30,960 --> 00:15:31,060
com diversos tipos de variáveis, mas eu acho que o que eu vou fazer é fazer um parâmetro de cada um dos parâmetros.

190
00:15:31,060 --> 00:15:37,480
Então eu vou usar os fatores desse número ou simplesmente ir variando manualmente os números, certo?

191
00:15:43,900 --> 00:16:00,940
Com isso nós obtemos 0,1 milissegundos. Nós podemos então rodar novamente o prototipo C++ com o OpenCV.

192
00:16:00,940 --> 00:16:12,160
Vamos1 milissegundos.

193
00:16:12,160 --> 00:16:19,300
E em comparação nos temos aí metade do tempo na média com o blooming.

194
00:16:27,920 --> 00:16:29,800
o que você pode ver é que a receita é mais rápida,Afinal de contas oito horas são bastante bem feitas para a Party e para bater uma entrada muito rápida.

195
00:16:29,800 --> 00:16:29,820
Certo?E em comparação nós temos ai metade do tempo na média com o Link.

196
00:16:29,820 --> 00:16:38,520
O que acontece se você tentar executar essa mesma operação sem o unroll, certo?

197
00:16:38,560 --> 00:16:39,840
Eu tenho o caso 5 aqui.

198
00:16:49,720 --> 00:16:50,240
Ok?

199
00:16:50,540 --> 00:16:59,300
Então, sem o unroll, a gente consegue chegar abaixo do OpenCV na média, certo?

200
00:16:59,820 --> 00:17:03,600
Mas não tão rápido quanto fazendo o unroll.

201
00:17:03,840 --> 00:17:10,820
Inclusive, é também ali no range de metade do tempo em relação a esse schedule sem o unroll.

202
00:17:14,520 --> 00:17:17,400
A gente pode testar também a reordenação.

203
00:17:17,400 --> 00:17:19,920
Nesse caso, sim.

204
00:17:29,820 --> 00:17:39,820
E aí também é um pouco mais rápido, mas o melhor tempo está na mesma ordem ali do nosso schedule 4.

205
00:17:41,460 --> 00:17:43,320
Aqui na média, no caso.

206
00:17:49,520 --> 00:17:56,980
Então, nós aplicamos o unroll para tanto possibilitar algumas otimizações do nosso código,

207
00:17:56,980 --> 00:17:58,980
como também...

208
00:17:59,820 --> 00:18:05,320
eliminar o MUX dentro do loop mais interno para a nossa pipelining.

209
00:18:08,320 --> 00:18:13,320
Como leitura recomendada, eu deixo para vocês tanto a lição de scheduling do RayLight,

210
00:18:13,320 --> 00:18:20,820
como também, novamente, o ponto em que RayLight define ali definições relacionadas às funks, certo?

211
00:18:20,820 --> 00:18:26,820
Que vai conter as definições do RayLight, as duas definições do RayLight para o unroll.

212
00:18:29,820 --> 00:18:33,320
Muito obrigado pela atenção de vocês e até a próxima.

