1
00:00:00,000 --> 00:00:06,240
Olá, seja muito bem-vindos a mais uma aula do curso de linguagem de programação específica

2
00:00:06,240 --> 00:00:13,400
para IA. Hoje iremos explorar mais alguns conceitos de scheduling. O caso do conceito

3
00:00:13,400 --> 00:00:21,120
de hoje será o Unroll. Ele, como a gente viu naquele exemplo idático com a geração

4
00:00:21,120 --> 00:00:27,520
de números de Fibonacci, pode ser utilizado para diminuir o número de interações a custo

5
00:00:27,520 --> 00:00:33,520
do tamanho do corpo do loop. Então nós vamos aumentar o corpo do loop a fim de diminuir

6
00:00:33,520 --> 00:00:44,200
o número de interações. A gente viu que ele tem o efeito de como se executasse múltiplas

7
00:00:44,200 --> 00:00:51,400
interações em o que seria um a só no loop transformado. Ele pode ser útil para quando

8
00:00:51,400 --> 00:00:58,120
a gente tem pixels que manipulam dados incomunes e um padrão específico que a gente vai ver

9
00:00:58,120 --> 00:01:03,800
frequentemente que às vezes é útil utilizar o Unroll é quando a gente tem mais de um

10
00:01:03,800 --> 00:01:11,160
canal e quer se pre-executar o assigne desses canais em sequência, então um atrás do outro

11
00:01:11,160 --> 00:01:19,360
sem uma criação de um novo loop. Ele tem duas sintaxes, a primeira delas é só passando

12
00:01:19,360 --> 00:01:25,960
um Avar para dentro desse Unroll e a outra Avar em um Fator. Ele vai ser utilizado com

13
00:01:25,960 --> 00:01:32,960
Bound ou com Split. No caso aqui, quando a gente quer fazer um Unroll por exemplo de

14
00:01:32,960 --> 00:01:38,920
um Avar que não seja um dos canais, a gente vai normalmente precisar fazer um Split dessa

15
00:01:38,920 --> 00:01:45,400
Avar, certo? E a gente faz o Split com o Fator e depois aplica um Unroll nessa Avar que vai

16
00:01:45,400 --> 00:01:54,080
estar ali bem interna no alinhamento do loop, certo? Uma outra opção é você fazer essa

17
00:01:54,080 --> 00:02:00,840
sintaxe aqui, Unroll, passando o Avar e depois o Fator. A diferença é que você vai ficar

18
00:02:00,840 --> 00:02:12,360
escondido o Split, certo? Ele vai esconder esse Split. Para o exemplo dos canais, o que

19
00:02:12,360 --> 00:02:18,200
a gente vai utilizar é esse Bound aqui. Então, nós vamos na verdade utilizar tanto o Reorder

20
00:02:18,200 --> 00:02:27,560
como o Bound para mover os canais para a parte mais interna do loop, certo? O Bound vai dizer

21
00:02:27,560 --> 00:02:34,400
para o Relight que a minha variável do canal é limitada entre 0 a 3, certo? Então ali RGB,

22
00:02:34,400 --> 00:02:42,280
sempre que eu trabalhar em Relight com o mínimo e o Extent, que é a extensão daquela dimensão.

23
00:02:42,680 --> 00:02:48,680
Então a gente vai passar para o Bound a variável, o mínimo que vai ser 0 e o Extent que vai ser 3,

24
00:02:48,680 --> 00:02:56,680
que são três canais. E a partir disso, né, diferentemente da sintaxe com o Split, a gente

25
00:02:56,680 --> 00:03:02,200
sabe os limites que esse loop vai percorrer, a gente sabe qual é os limites da minha variável.

26
00:03:02,200 --> 00:03:09,440
Então a gente utiliza o Bound para passar essa informação para o Unroll depois. No caso onde a

27
00:03:09,440 --> 00:03:14,800
gente não sabe a dimensão do loop, que vai ser nos casos onde a gente tem uma variável que não

28
00:03:14,800 --> 00:03:20,240
seja aquela dos canais, por exemplo, a gente vai estar utilizando essa sintaxe com o Split.

29
00:03:22,560 --> 00:03:29,240
Iremos agora verificar na prática a utilização do Unroll. Eu tenho aqui um exemplo onde eu estou

30
00:03:29,240 --> 00:03:36,600
aplicando um efeito Sap em uma imagem, certo? Então nós temos um efeito de falta antiga sendo aplicado.

31
00:03:37,600 --> 00:03:44,600
Primeiramente mostrando o protótipo de Python para a gente ter um guia da temporização, certo,

32
00:03:44,600 --> 00:03:50,080
do runtime dessa pipeline. Eu vou rodar o protótipo aqui.

33
00:03:50,080 --> 00:04:09,560
E nós temos em Python a velocidade ali de 20, no caso está demorando 23 milisegundos,

34
00:04:09,560 --> 00:04:15,920
no caso 24 milisegundos, para completar a execução da pipeline na média. No pior

35
00:04:15,920 --> 00:04:22,520
caso está em 46 milisegundos e no melhor caso 20 milisegundos. A pipeline é simples,

36
00:04:22,520 --> 00:04:31,040
ela só envolve multiplicar os canais da imagem por diversos fatores, certo? Cada canal novo vai

37
00:04:31,040 --> 00:04:37,600
ter um conjunto de três fatores associados a ele, certo? Então cada novo canal da imagem, cada novo

38
00:04:37,600 --> 00:04:46,360
RGIB é uma ponderação dos RGIB anteriores, iniciais. Após isso eu faço o merging desses canais,

39
00:04:46,360 --> 00:04:54,280
converto para a Uinti8 a versão clipada dele, ou seja, mantida ali entre 0 e 55.

40
00:04:57,280 --> 00:05:01,240
Eu tenho aqui também um protótipo implementado em C++ com OpenCV.

41
00:05:01,240 --> 00:05:14,040
Então é a nossa segunda referência de tempo e nós esperamos um tempo um pouco

42
00:05:14,040 --> 00:05:17,480
menor de execução em relação ao Python.

43
00:05:31,480 --> 00:05:42,360
Já temos aqui o resultado do OpenCV, está igualzinho ao do Python e no caso a gente tem aqui

44
00:05:42,360 --> 00:05:55,800
0,3 milisegundos na média, certo? Em comparação ao Python com seus 23 milisegundos. No melhor caso

45
00:05:55,880 --> 00:06:04,520
0,19 milisegundos e no pior caso 4 milisegundos, certo? Então está bem mais rápido que o Python.

46
00:06:04,520 --> 00:06:08,360
Vamos então ver se a gente consegue chegar mais rápido com o Relight.

47
00:06:11,720 --> 00:06:18,840
Então eu tenho aqui a pipeline implementada no Relight com o generator e com um parâmetro

48
00:06:18,840 --> 00:06:33,320
para selecionar o schedule customizado. E aí o que a gente tem aqui é esse mox e aí no caso a gente

49
00:06:33,320 --> 00:06:42,440
vai poder observar uma das maiores utilidades do Unroll, que é a eliminação do select para fazer

50
00:06:42,440 --> 00:06:49,640
a assign dos canais. Então a gente tem um mox aqui e a gente consegue converter, ao invés de ter

51
00:06:49,640 --> 00:06:57,080
essa multiplexação, a gente vai converter isso daqui para executar o assign um depois do outro

52
00:06:57,080 --> 00:07:08,840
ali dentro do loop mais interno da minha pipeline. Então eu tenho aqui primeiro a utilização com

53
00:07:08,840 --> 00:07:15,000
um canalismo apenas sendo aplicado no Y, se você não sabe dessa imagem. Então nós vamos verificar

54
00:07:15,000 --> 00:07:20,120
ainda sem o Unroll, certo? Uma aplicação mais simples de Skylark.

55
00:07:31,960 --> 00:07:38,360
Ao executar isso aqui a gente obtém um código também bem mais rápido que o Python, mas mais lento

56
00:07:38,360 --> 00:07:54,280
que o OpenCV. Inclusive o melhor tempo dessa execução em Relight é assinando a média em relação ao OpenCV.

57
00:08:01,240 --> 00:08:07,320
Nós podemos então agora verificar o statement file que eu tenho já carregado aqui, eu só preciso

58
00:08:07,320 --> 00:08:16,440
ligar essa página, vamos fechar o assembly e verificar aqui que a gente tem esse mox aqui

59
00:08:16,440 --> 00:08:26,840
dentro, internamente no... a gente tem aqui o Y sendo executado em paralelo e dentro do

60
00:08:26,920 --> 00:08:32,600
do Y, a parte mais interna tem esse mox aqui, certo?

61
00:08:40,360 --> 00:08:46,840
Então vamos remover esse mox. Como a gente viu nos slides, a gente tem que utilizar algumas

62
00:08:46,840 --> 00:08:53,880
diretivas junto do meu Unroll para poder ter o comportamento que nós esperamos. A primeira

63
00:08:53,960 --> 00:08:58,920
que a gente precisa fazer como mencionado é o Reorder, nós precisamos mover os canais para a

64
00:08:58,920 --> 00:09:05,720
parte mais interna do loop, certo? A gente tem que garantir que eles estejam na parte mais interna do

65
00:09:05,720 --> 00:09:14,760
alinhamento do loop. Seguinte a isso, utilizamos o Bound para estabelecer os limites da minha var,

66
00:09:14,760 --> 00:09:21,640
que são os canais, e aí eu tenho o mínimo que é zero e a extensão dessa minha dimensão, que

67
00:09:21,640 --> 00:09:30,040
é 6, então a gente vai de zero até 2, né? Zero, um e dois. E seguinte a isso nós executamos o

68
00:09:30,040 --> 00:09:37,640
Unroll. Eu posso remover isso aqui para que a gente veja um efeito que pode ser observado

69
00:09:37,640 --> 00:09:44,920
quando vocês estiverem utilizando essas diretivas, certo? Então ao rodar o caso 1,

70
00:09:51,640 --> 00:10:00,600
a gente tem ainda uma papelada um pouco mais lenta inclusive, e ao verificar a atualização aqui do

71
00:10:00,600 --> 00:10:20,760
Statement File, vou aumentar um pouco, nós temos o seguinte, são três versões aqui da minha

72
00:10:20,840 --> 00:10:26,960
observação, certo? Uma para cada um daqueles canais, então é como se o rodador estivesse

73
00:10:26,960 --> 00:10:32,040
considerando o C, o canal, como o loop mais externo.

74
00:10:32,040 --> 00:10:56,640
Estamos executando agora com o Compute Root, para ver o que o Lila está fazendo por padrão

75
00:10:56,960 --> 00:11:02,960
com essa nossa plato-line. Eu vou recarregar o meu Statement File,

76
00:11:07,360 --> 00:11:16,000
e como esperado o C, o canal, ele está aqui no loop mais externo, então ao fazer o Unroll,

77
00:11:16,000 --> 00:11:25,920
a gente estabelece esse extente aqui com o Bound, certo? E ao fazer o Unroll sem o Reorder, ele vai

78
00:11:26,720 --> 00:11:32,960
desenrolar essa computação em três loops diferentes, então três loops por toda a imagem diferente.

79
00:11:37,840 --> 00:11:46,160
Vamos então remover e passar a fazer o Reorder junto com as duas outras diretivas.

80
00:11:46,160 --> 00:12:07,280
A gente tem um pouco mais rápido do que o nosso teste inicial com aqueles três loops,

81
00:12:07,280 --> 00:12:13,280
certo? Mas ainda não tão rápido quanto o Parallel e também não tão rápido quanto o OpenCV.

82
00:12:13,920 --> 00:12:18,240
Vamos então prosseguir com o scheduling dessa plato-line,

83
00:12:18,240 --> 00:12:26,000
mas antes passando para verificar a nova estrutura obtida no Statement File.

84
00:12:29,040 --> 00:12:35,520
Então nós temos aqui que temos o loop mais externo, e meio de output pelo Y,

85
00:12:35,520 --> 00:12:42,000
depois pelo X, e os três canais sendo feito o Assign em sequência, um após o outro.

86
00:12:43,280 --> 00:12:54,880
E iremos então passar para o caso dois, que é a aplicação do Parallelismo após

87
00:12:54,880 --> 00:13:00,640
esse Unroll, certo? Dessa forma com o Reorder e o Bound.

88
00:13:00,640 --> 00:13:15,920
Achamos agora um aumento na velocidade em comparação inclusive ao Schedule 0 aqui,

89
00:13:15,920 --> 00:13:29,360
onde a gente chegou a 0.29 milissegundos, com o OpenCV aqui já na média, já atingindo um valor menor, certo?

90
00:13:31,120 --> 00:13:42,320
Inclusive o pior caso também já tem uma boa diferença. Nós podemos prosseguir com o nosso

91
00:13:42,320 --> 00:13:51,040
Schedule fazendo, testando o Splitting e executando o Parallelismo a partir desse Splitting do Y,

92
00:13:51,040 --> 00:13:57,280
certo? Então ao invés de paralisar a VAR Y pura, a gente vai fazer o Splitting nela antes de aplicar

93
00:13:57,920 --> 00:14:04,400
o Parallelismo. E novamente, como antes, eu estou utilizando o Vector Size, obtido com a função

94
00:14:04,400 --> 00:14:12,080
Natural Vector Size do Relight, como uma guia para minha experimentação. É só um valor que eu posso

95
00:14:12,080 --> 00:14:19,440
rapidamente experimentar vários fatores dele como uma guia, certo? No caso aqui eu estou multiplicando ele por 8.

96
00:14:19,440 --> 00:14:25,520
Então nós vamos executar aqui o caso 3.

97
00:14:32,680 --> 00:14:43,200
Ele é um pouco mais lento que a versão anterior. A gente pode experimentar também modificar esse Vector Size

98
00:14:43,200 --> 00:14:49,280
e ver se a gente obtém um tempo um pouco melhor.

99
00:14:53,320 --> 00:14:57,920
Ele está um pouco mais rápido, mas ainda assim ele não superou o nosso Schedule 2.

100
00:14:58,680 --> 00:15:05,520
Nós iremos então observar o Schedule 4, onde a gente encadeia o Splitting com a Vectorização,

101
00:15:05,520 --> 00:15:10,880
certo? O Parallelismo com a Vectorização. Nós executamos o nosso Unroll,

102
00:15:13,360 --> 00:15:19,680
fazemos o Splitting do Y e aplicamos o Parallelismo na variável mais externa,

103
00:15:20,600 --> 00:15:27,360
e fazemos o Splitting do X e aplicamos a Vectorização na variável mais interna, certo?

104
00:15:28,360 --> 00:15:37,360
Novamente a gente pode experimentar com diversos fatores desse número ou simplesmente ir variando manualmente os números, certo?

105
00:15:37,360 --> 00:15:42,360
Com isso nós obtemos 0,1 milissegundos.

106
00:15:43,360 --> 00:15:53,360
Nós podemos então rodar novamente o Prototype em C++, como você vê.

107
00:16:07,360 --> 00:16:19,360
Certo? E em comparação nós temos aí metade do tempo na média com o Relight.

108
00:16:19,360 --> 00:16:40,360
E aí para observar o que acontece se você tenta executar essa mesma operação sem o Unroll, certo? Eu tenho caso 5 aqui.

109
00:16:50,360 --> 00:17:03,360
Então sem o Unroll a gente consegue chegar abaixo do OpenCV na média, certo? Mas não tão rápido quanto fazendo o Unroll.

110
00:17:04,360 --> 00:17:11,360
Inclusive, também ali no range de metade do tempo em relação a esse Schedule sem o Unroll.

111
00:17:11,360 --> 00:17:20,360
A gente pode testar também a Reordenação, nesse caso 5.

112
00:17:20,360 --> 00:17:40,360
E aí também um pouco mais rápido, mas o melhor tempo está na mesma ordem ali do nosso Schedule, 4.

113
00:17:41,360 --> 00:17:44,360
Aqui na média, no caso.

114
00:17:44,360 --> 00:18:05,360
Então nós aplicamos o Unroll para tanto possibilitar algumas otimizações do nosso código como também eliminar o MOOCs dentro do loop mais interno da nossa pipeline.

115
00:18:05,360 --> 00:18:20,360
Como letra recomendada, eu deixo para vocês tanto a lição de Scheduling do Relight como também novamente o ponto em que Relight define ali definições relacionadas às Funcs, certo?

116
00:18:21,360 --> 00:18:26,360
Que vai conter as definições do Relight, as duas definições do Relight para o Unroll.

117
00:18:27,360 --> 00:18:32,360
Muito obrigado pela atenção de vocês e até a próxima.

