1
00:00:00,000 --> 00:00:07,000
 Olá, seja muito bem-vindos a mais uma aula no curso de linguagem de programação específica para IA.

2
00:00:07,000 --> 00:00:12,000
 Hoje iremos explorar mais alguns conceitos de Skyrim.

3
00:00:12,000 --> 00:00:15,000
 O caso do conceito de hoje será o Unroll.

4
00:00:16,000 --> 00:00:23,000
 Como vimos naquele exemplo didático com a geração de números de fibonate,

5
00:00:23,000 --> 00:00:30,000
 pode ser utilizado para diminuir o número de interações a custo do tamanho do corpo do loop.

6
00:00:30,000 --> 00:00:35,000
 Então, vamos aumentar o corpo do loop para diminuir o número de interações.

7
00:00:35,000 --> 00:00:45,000
 A gente viu que ele tem um efeito de como se executassem múltiplas interações

8
00:00:45,000 --> 00:00:49,000
 em o que seria um a só no loop transformado.

9
00:00:49,000 --> 00:00:54,000
 Ele pode ser útil para quando a gente tem pixels que manipulam dados em comunes

10
00:00:54,000 --> 00:00:59,000
 e um padrão específico que a gente vai ver frequentemente,

11
00:00:59,000 --> 00:01:04,000
 e às vezes é útil utilizar o Unroll quando a gente tem mais de um canal

12
00:01:04,000 --> 00:01:10,000
 e quer se perte executar o Assign desses canais, em sequência,

13
00:01:10,000 --> 00:01:14,000
 um atrás do outro sem uma criação de um novo loop.

14
00:01:14,000 --> 00:01:21,000
 Ele tem duas sintaxes, a primeira delas é só passando um Avar para dentro desse Unroll

15
00:01:21,000 --> 00:01:24,000
 e a outra Avar em um fator.

16
00:01:24,000 --> 00:01:27,000
 Ele vai ser utilizado com Bound ou com Split.

17
00:01:27,000 --> 00:01:32,000
 No caso aqui, quando a gente quer fazer um Unroll por exemplo,

18
00:01:32,000 --> 00:01:35,000
 de um Avar que não sejam os canais,

19
00:01:35,000 --> 00:01:40,000
 a história normalmente precisa fazer um Split dessa Avar, certo?

20
00:01:40,000 --> 00:01:44,000
 E a gente faz o Split com um fator e depois aplica um Unroll nessa Avar

21
00:01:44,000 --> 00:01:50,000
 que vai estar ali bem interna no alinhamento do loop, certo?

22
00:01:50,000 --> 00:01:55,000
 Uma outra opção é você se pente fazer essa sintax aqui,

23
00:01:55,000 --> 00:01:59,000
 um Unroll passando o Avar e depois o fator.

24
00:01:59,000 --> 00:02:07,000
 A diferença é que você vai ficar escondido o Split, certo?

25
00:02:07,000 --> 00:02:10,000
 Ele vai esconder esse Split.

26
00:02:10,000 --> 00:02:15,000
 Para o exemplo dos canais, a gente vai estar utilizando esse Bound aqui.

27
00:02:15,000 --> 00:02:20,000
 Então, nós vamos, na verdade, utilizar tanto o Reorder como o Bound

28
00:02:20,000 --> 00:02:25,000
 para mover os canais para a parte mais interna do loop, certo?

29
00:02:25,000 --> 00:02:30,000
 O Bound, ele vai dizer para o Relide que a minha variável do canal

30
00:02:30,000 --> 00:02:33,000
 é limitada entre 0 a 3, certo?

31
00:02:33,000 --> 00:02:36,000
 Então ali, RGB, sempre que vai trabalhar em Relide

32
00:02:36,000 --> 00:02:42,000
 com o mínimo e o Extend, que é a extensão daquela dimensão.

33
00:02:42,000 --> 00:02:45,000
 Então, a gente vai passar para o Bound a variável,

34
00:02:45,000 --> 00:02:48,000
 o mínimo que vai ser 0 e o Extend que vai ser 3,

35
00:02:48,000 --> 00:02:51,000
 aqui são 3 canais.

36
00:02:51,000 --> 00:02:56,000
 E a partir disso, diferentemente da sintax com o Split,

37
00:02:56,000 --> 00:03:00,000
 a gente sabe os limites que esse loop vai percorrer,

38
00:03:00,000 --> 00:03:02,000
 a gente sabe qual é o limite da minha variável.

39
00:03:02,000 --> 00:03:06,000
 Então, a gente utiliza o Bound para passar essa informação

40
00:03:06,000 --> 00:03:08,000
 para o Unroll depois.

41
00:03:08,000 --> 00:03:12,000
 No caso, onde a gente não sabe a dimensão do looping,

42
00:03:12,000 --> 00:03:14,000
 que vai ser, nos casos onde a gente tem uma variável

43
00:03:14,000 --> 00:03:16,000
 que não seja aquela dos canais, por exemplo,

44
00:03:16,000 --> 00:03:22,000
 a gente vai ter que estar utilizando essa sintax com o Split.

45
00:03:22,000 --> 00:03:26,000
 Iremos agora verificar na prática a utilização do Unroll.

46
00:03:26,000 --> 00:03:28,000
 Eu tenho aqui um exemplo,

47
00:03:28,000 --> 00:03:32,000
 onde eu estou aplicando um efeito 7nm, certo?

48
00:03:32,000 --> 00:03:38,000
 Então, nós temos um efeito de falta antiga sendo aplicado.

49
00:03:38,000 --> 00:03:42,000
 Primeiramente, mostrando o Protótipo de Python para a gente ter um guia

50
00:03:42,000 --> 00:03:48,000
 da temporização, certo, do runtime da pipeline.

51
00:03:48,000 --> 00:03:58,000
 Eu vou rodar o Protótipo aqui.

52
00:03:58,000 --> 00:04:06,000
 E nós temos, em Python, a velocidade de 20,

53
00:04:06,000 --> 00:04:12,000
 no caso ele está demorando 23 ms, no caso 24 ms,

54
00:04:12,000 --> 00:04:16,000
 para completar a execução da pipeline na média.

55
00:04:16,000 --> 00:04:20,000
 No pior caso, está em 46 ms e, no melhor caso, 20 ms.

56
00:04:20,000 --> 00:04:24,000
 A pipeline é simples, ela só envolve,

57
00:04:24,000 --> 00:04:28,000
 multiplicar os canais da imagem por diversos fatores, certo?

58
00:04:28,000 --> 00:04:34,000
 Cada canal novo, ele vai ter 3 fatores associados a ele, certo?

59
00:04:34,000 --> 00:04:38,000
 Então, cada novo canal da imagem, cada novo RGIB,

60
00:04:38,000 --> 00:04:42,000
 é uma ponderação dos RGIB anteriores, iniciais.

61
00:04:42,000 --> 00:04:46,000
 Após isso, eu faço a merging desses canais,

62
00:04:46,000 --> 00:04:52,000
 converto para a versão clipada dele,

63
00:04:52,000 --> 00:04:56,000
 ou seja, mantida ali entre 0 e 35.

64
00:04:56,000 --> 00:05:02,000
 Eu tenho aqui também um Protótipo implementado em C++, com OpenCV.

65
00:05:02,000 --> 00:05:08,000
 Então, é a nossa segunda referência de tempo,

66
00:05:08,000 --> 00:05:18,000
 e nós esperamos um tempo pouco menor de execução em relação ao Python.

67
00:05:32,000 --> 00:05:38,000
 Já o termos aqui, o resultado do OpenCV,

68
00:05:38,000 --> 00:05:40,000
 está igualzinho ao do Python.

69
00:05:40,000 --> 00:05:48,000
 E, no caso, a gente tem aqui 0,3 ms na média, certo?

70
00:05:48,000 --> 00:05:54,000
 Em comparação ao Python, com os seus 23 ms.

71
00:05:54,000 --> 00:06:00,000
 No melhor caso, a gente tem 0,19 ms, e no pior caso, 4 ms.

72
00:06:00,000 --> 00:06:04,000
 Então, está bem mais rápido que o Python.

73
00:06:04,000 --> 00:06:10,000
 Vamos, então, ver se a gente consegue chegar mais rápido com o Relide.

74
00:06:10,000 --> 00:06:16,000
 Então, eu tenho aqui a plana implementada no Relide com Generator,

75
00:06:16,000 --> 00:06:24,000
 e com um parâmetro aqui para selecionar os carros que estão amizados, certo?

76
00:06:24,000 --> 00:06:30,000
 E aí, o que a gente tem aqui é esse Mox.

77
00:06:30,000 --> 00:06:38,000
 E aí, no caso, a gente vai poder observar uma das maiores utilidades do Unroll,

78
00:06:38,000 --> 00:06:44,000
 que é a eliminação do Select para fazer esse Assign dos canais, certo?

79
00:06:44,000 --> 00:06:48,000
 Então, a gente tem um Mox aqui e a gente consegue converter,

80
00:06:48,000 --> 00:06:54,000
 ao invés de ter essa multiplexação, a gente vai converter isso aqui

81
00:06:54,000 --> 00:07:04,000
 para executar o Assign um depois do outro ali, dentro do loop mais interno da minha pipeline.

82
00:07:04,000 --> 00:07:08,000
 Então, eu tenho aqui primeiro a utilização,

83
00:07:08,000 --> 00:07:12,000
 com o paralelismo apenas sendo aplicado no Y, no site da sem-mai.

84
00:07:12,000 --> 00:07:16,000
 Então, nós vamos verificar, ainda sem o Unroll, certo?

85
00:07:16,000 --> 00:07:20,000
 Uma aplicação mais simples de carros.

86
00:07:32,000 --> 00:07:36,000
 Ao executar isso aqui, a gente obtém um código bem mais rápido que o Python,

87
00:07:36,000 --> 00:07:42,000
 mais lento que o OPCV.

88
00:07:42,000 --> 00:07:54,000
 Inclusive, o melhor tempo dessa execução em real-ight é assinando a média em relação ao OPCV, certo?

89
00:07:54,000 --> 00:08:06,000
 Nós podemos, então, agora verificar o Satan File, que eu tenho já carregado aqui,

90
00:08:06,000 --> 00:08:10,000
 eu só preciso recarregar essa página, vamos fechar o Assembly,

91
00:08:10,000 --> 00:08:18,000
 e verificar aqui que a gente tem esse Mox aqui dentro internamente no...

92
00:08:18,000 --> 00:08:24,000
 A gente tem aqui o Y sendo executado em paralelo,

93
00:08:24,000 --> 00:08:32,000
 e dentro do Mox, na parte mais interna, tem esse Mox aqui, certo?

94
00:08:40,000 --> 00:08:44,000
 Então, vamos remover esses Mox.

95
00:08:44,000 --> 00:08:50,000
 Como a gente viu nos islades, a gente tem que utilizar algumas diretivas junto do meu Unroll,

96
00:08:50,000 --> 00:08:53,000
 para poder ter o comportamento que nós esperamos.

97
00:08:53,000 --> 00:08:56,000
 A primeira delas, como mencionado, é o ReOrder.

98
00:08:56,000 --> 00:09:01,000
 Nós precisamos mover os canais para a parte mais interna do loop,

99
00:09:01,000 --> 00:09:07,000
 certo? A gente tem que garantir que eles estejam na parte mais interna do alinhamento de loop.

100
00:09:07,000 --> 00:09:16,000
 Seguinte a isso, utilizamos um Bound para estabelecer os limites da minha VAR, que são os canais.

101
00:09:16,000 --> 00:09:22,000
 E aí, eu tenho o mínimo, que é 0, e a extensão dessa minha dimensão, que vai ser 3.

102
00:09:22,000 --> 00:09:26,000
 Então, a gente vai de 0 até 2, 0, 1 e 2.

103
00:09:26,000 --> 00:09:30,000
 E, seguinte a isso, nós executamos o Unroll.

104
00:09:30,000 --> 00:09:37,000
 Eu posso remover isso aqui para que a gente veja um efeito que pode ser observado

105
00:09:37,000 --> 00:09:42,000
 quando vocês estiverem utilizando essas diretivas, certo?

106
00:09:42,000 --> 00:09:56,000
 Então, ao rodar o caso 1, a gente tem ainda uma papelária um pouco mais lente, inclusive,

107
00:09:56,000 --> 00:10:04,000
 e ao verificar a atualização aqui do statement file,

108
00:10:04,000 --> 00:10:12,000
 vou aumentar um pouco.

109
00:10:12,000 --> 00:10:22,000
 Nós temos o seguinte, são três versões aqui da minha execução, certo?

110
00:10:22,000 --> 00:10:25,000
 É só para cada um daqueles canais.

111
00:10:25,000 --> 00:10:50,000
 Então, é como se ele estivesse considerando o C, o canal, como o loop mais externo.

112
00:10:50,000 --> 00:11:00,000
 Vamos executando agora com o compute root, para ver o que ele está fazendo por padrão com essa nossa pipeline.

113
00:11:00,000 --> 00:11:07,000
 Eu vou recarregar o meu statement file.

114
00:11:07,000 --> 00:11:14,000
 E, como esperado, o C, o canal, ele está aqui no loop mais externo.

115
00:11:14,000 --> 00:11:22,000
 Então, ao fazer o Unroll, a gente estabelece esse extent aqui com o bound, certo?

116
00:11:22,000 --> 00:11:30,000
 E, ao fazer o Unroll sem o Reorder, ele vai desenrolar essa computação em três loops diferentes, certo?

117
00:11:30,000 --> 00:11:38,000
 Então, três loops por toda imagem diferente.

118
00:11:38,000 --> 00:11:56,000
 Vamos, então, remover e passar a fazer o order junto com as duas outras diretivas.

119
00:11:57,000 --> 00:12:08,000
 A gente tem um pouco mais rápido do que o nosso teste inicial com aqueles três loops, certo?

120
00:12:08,000 --> 00:12:14,000
 Mas ainda não tão rápido quanto o paralelo e também não quanto o OpenCV.

121
00:12:14,000 --> 00:12:18,000
 Vamos, então, prosseguir com o scheduling dessa pipeline,

122
00:12:18,000 --> 00:12:29,000
 mas antes, passando para verificar a nova estrutura obtida no statement file.

123
00:12:29,000 --> 00:12:37,000
 Então, nós temos aqui que temos o loop mais externo em meio de output pelo Y, depois pelo X,

124
00:12:37,000 --> 00:12:49,000
 e os três canais sendo feito o Assign em sequência, um após o outro.

125
00:12:49,000 --> 00:12:57,000
 Iremos, então, passar para o caso 2, que é a aplicação do paralelismo após esse Unroll, certo?

126
00:12:57,000 --> 00:13:10,000
 Então, vamos ver com o Reorder e o bounding.

127
00:13:10,000 --> 00:13:18,000
 Achemos agora um aumento na velocidade, em comparação, inclusive, a o schedule 0 aqui.

128
00:13:19,000 --> 00:13:30,000
 Quando a gente chegou a 0.29 milissegundos, com o OpenCV aqui, na média, já atingindo um valor menor, certo?

129
00:13:30,000 --> 00:13:34,000
 Inclusive, o pior caso também.

130
00:13:34,000 --> 00:13:37,000
 Tem uma boa diferença.

131
00:13:37,000 --> 00:13:51,000
 Nós podemos prosseguir com o nosso scheduling, testando um splitting e executando o paralelismo a partir desse splitting do Y, certo?

132
00:13:51,000 --> 00:13:58,000
 Então, em vez de paralelizar a var Y pura, a gente vai fazer um splitting nela antes de aplicar o paralelismo.

133
00:13:58,000 --> 00:14:10,000
 E, novamente, como antes, eu estou utilizando vector size, obtido com a função natural vector size do realize, como uma guia para minha experimentação.

134
00:14:10,000 --> 00:14:17,000
 É só um valor que eu posso, rapidamente, experimentar vários fatores dele, como uma guia, certo?

135
00:14:17,000 --> 00:14:22,000
 No caso aqui, eu estou multiplicando ele por 8.

136
00:14:22,000 --> 00:14:26,000
 Então, nós vamos executar aqui o caso 3.

137
00:14:32,000 --> 00:14:36,000
 Era um pouco mais lento que a versão dele ovo.

138
00:14:36,000 --> 00:14:43,000
 A gente pode experimentar também modificar esse vector size.

139
00:14:44,000 --> 00:14:49,000
 Vê se a gente obtém um tempo um pouco melhor.

140
00:14:53,000 --> 00:14:58,000
 Ele está um pouco mais rápido, mas ainda assim não superou o nosso schedule 2.

141
00:14:58,000 --> 00:15:05,000
 Nós iremos então observar o schedule 4, onde a gente tem cadeia o splitting com a vectorização, certo?

142
00:15:05,000 --> 00:15:08,000
 O paralelismo com a vectorização.

143
00:15:08,000 --> 00:15:11,000
 Nós executamos o nosso unroll.

144
00:15:13,000 --> 00:15:20,000
 Fazemos o splitting do y e aplicamos o paralelismo na variável mais externa.

145
00:15:20,000 --> 00:15:28,000
 E fazemos o splitting do x e aplicamos a vectorização na variável mais interna, certo?

146
00:15:28,000 --> 00:15:38,000
 Obviamente, a gente pode experimentar com diversos fatores desse número, ou simplesmente variando manualmente os números, certo?

147
00:15:44,000 --> 00:15:50,000
 Com isso, nós obtemos 0,1 milissegundos.

148
00:15:50,000 --> 00:15:59,000
 Nós podemos então rodar novamente o prototipin, de C++, com o opcv.

149
00:15:59,000 --> 00:16:19,000
 E em comparação, nós temos a metade do tempo na média com o highlight.

150
00:16:19,000 --> 00:16:38,000
 E aí, para observar o que acontece, você tenta executar essa mesma operação sem o unroll, certo?

151
00:16:38,000 --> 00:16:40,000
 Eu tenho um caso 5 aqui.

152
00:16:50,000 --> 00:17:00,000
 Então, sem o unroll, a gente consegue chegar abaixo do opcv na média, certo?

153
00:17:00,000 --> 00:17:04,000
 Mas não tão rápido quanto fazendo o unroll.

154
00:17:04,000 --> 00:17:12,000
 Inclusive, é também no range de metade do tempo em relação a esse schedule sem o unroll.

155
00:17:13,000 --> 00:17:20,000
 A gente pode testar também a reordenação, esse caso 5.

156
00:17:31,000 --> 00:17:40,000
 E aí, também, um pouco mais rápido, mas o melhor tempo está na mesma ordem do nosso schedule 4.

157
00:17:42,000 --> 00:17:44,000
 Aqui na média, no caso.

158
00:17:50,000 --> 00:17:57,000
 Então, nós aplicamos o unroll para, tanto, possibilitar algumas otimizações do nosso código,

159
00:17:57,000 --> 00:18:06,000
 como também eliminar o moose dentro do loop mais interno para o nosso pipeline.

160
00:18:07,000 --> 00:18:13,000
 Como a gente vai recomendada, eu deixo para vocês tanto a lição de scheduling do highlight,

161
00:18:13,000 --> 00:18:20,000
 como também novamente o ponto entre highlight definições relacionadas às funks,

162
00:18:20,000 --> 00:18:27,000
 que vai conter as definições do highlight, as duas definições do highlight, para o unroll.

163
00:18:30,000 --> 00:18:33,000
 Muito obrigado pela atenção de vocês e até a próxima.

