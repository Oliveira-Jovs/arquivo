Olá, seja muito bem-vindos a mais uma aula do curso de linguagem de programação específica para iar. Hoje, podemos esforar mais alguns conceitos de scheduling. Caso o conceito de hoje será o un roll. Como a gente viu naquele exemplo idáctico com a geração de linguagem tribunante, pode ser utilizado para diminuir o número de terações a custa do tamanho do corpo do loop. Então, vamos aumentar o corpo do loop. Afinhe diminuir o número de terações. A gente pode, a gente viu que ele tem um efeito de como se executasse multiple terações em o que seria uma só no loop transformado. Ele pode ser útil para quando a gente tem pixels que manipulam dados em comuns e um padrão específico que a gente vai ver frequentemente que, as vezes, é útil utilizar o um roll. É quando a gente tem mais de um canal e quer se proteger por estar o assign desses canais, certo? Em sequência, então, um atragem o outro sem uma criação de um novo loop. Ele tem duas sintaxis, a primeira delas é só passando um avar para dentro desse um roll e a outra avar é um fator. Ele vai ser utilizado com um bound ou com split. No caso aqui, quando a gente quer fazer um roll, por exemplo, de um avar que não seja os canais, a gente normalmente precisa fazer um split dessa avar, certo? E a gente faz um split com um fator e depois aplica um roll nessa avar, que vai estar ali bem interna no alinhamento do loop, certo? Uma outra opção é você se prende fazer essa sintaxis aqui em roll passando o avar e depois o fator. A diferença que você vai ficar escondido o split, certo? Ele vai esconder esse split. Para o exemplo dos canais, a gente vai estar utilizando esse bound aqui. Então, nós vamos, na verdade, utilizar tanto o rewarder como o bound para mover os canais, para a parte mais interna do loop, certo? O bound, ele vai dizer por relied que a minha variável do canal é limitada entre 0 a 3, certo? Então, ele é RGB, a gente sempre vai trabalhar em relied com o mínimo e o extente. Aqui é o... a extensão daquela dimensão. Então, a gente vai passar para o bound a variável, o mínimo que vai ser 0 e o extente que vai ser 3, que são 3 canais. E a partir disso, diferentemente das tráxias aqui com o split, a gente sabe os limites que esse loop vai percorrer, a gente sabe qual é os limites da minha variável. Então, a gente tem o utilizo o bound para passar essa informação para um roll depois. No caso, onde a gente não sabe a dimensão do loop, que vai ser, nos casos, a gente tem uma variável, que não seja aquela dos canais, por exemplo, a gente vai estar utilizando essa syntax com o split. Eremos agora verificar na prática a utilização do roll. Eu tenho aqui um exemplo, onde eu estou aplicando um efeito sep em uma imagem, certo? Então, nós temos um efeito de falta antiga sendo aplicado. Primeiramente, mostrando o protótipo de Python para a gente ter um dia da temporização, certo? do runtime dessa pipeline, eu vou rodar o protótipo aqui. E nós temos em Python. A velocidade dele de 20, em casa ele está demorando 23 mil segundos, no caso 24 mil segundos, para completar a execução da pipeline na média, no pior caso, está em 46 mil segundos e no melhor caso 20 mil segundos. A pipeline ela é simples, ela só envolve. Multiplicar os canais da imagem por diversos fatores, certo? Cada canal novo, ele vai ter um conjunto de três fatores associado a ele, certo? Então, cada novo canal da minha imagem, cada novo RJB, é uma ponderação dos RJB anteriores, né? Após isso eu faço mergem desses canais, converto para e o intuito, a versão clipada dele, ou seja, mantida entre 0 e 35. Eu tenho aqui também um protótipo, instrumentado em ser mais mais com OpenCV, então, é a nossa segunda referência de tempo, e nós esperamos um tempo um pouco menor de execução em relação ao Python. De algo que temos aqui, o resultado do OpenCV está igualzinho ao do Python, e no caso a gente tem aqui 0,3 mil segundos na média, certo? Em comparação ao Python, com seus 23 mil segundos, no maior caso a gente tem 0,19 mil segundos e no pior caso, 4 mil segundos, certo? Então, é bem mais rápido que o Python. Vamos então ver se a gente consegue chegar mais rápido com o reliable. Então, eu tenho aqui para ir implementada no RayLide, com um generator, e com um parâmetro aqui para selecionar o Skydoll somizado, certo? E aí, o que a gente tem aqui é esse Mox, e aí, no caso, a gente vai poder observar um das maiores utilidades do Unroll, que é a eliminação do Select para fazer esse a-sign dos canais, certo? Então, a gente tem um Mox aqui, a gente consegue converter, a gente tem essa multiplicação, a gente vai converter isso daqui, para executar o a-sign, um deporte do outro ali, dentro do loop mais interno da minha pipeline. Então, eu tenho aqui primeiro a utilização, com o paralelismo apenas sendo aplicado no e-sign, então, nós vamos verificar ainda sem o Unroll, certo? Uma aplicação mais simples de Skydoll. Ao executar isso aqui, a gente obtém um código, também bem mais rápido que o Python, mais lento que o OPCV, inclusive, o melhor tempo dessa execução em RayLide é estar assim na da média em relação ao OPCV, certo? Nós podemos, então, agora verificar o seito em file, que eu tenho já canegado aqui, só preciso carregar essa página, vamos fechar o assembly, e verificar aqui, na que a gente tem esse Mox aqui dentro, internamente no... a gente tem que o e-sign se não sendo executado em paralelo, e dentro do X, na parte mais interna a gente tem esse Mox aqui, certo? Então, vamos remover esse Mox. Como a gente viu, meus idade, a gente tem que utilizar algumas diretivas junto do meu Unroll para poder ter o comportamento que nós esperamos. A primeira delas, como mencionada, nós precisamos mover os canais para a parte mais interna do loop, certo? A gente tem que garantir que eles tejam na parte mais interna do aninhamento do loop. Seguinte é isso, utilizamos um bound para estabelecer os vimites do da minha var, que é os canais. E aí, eu tenho o mínimo que é zero e a extensão dessa minha dimensão, que vai ser o 3, então, isso vai de zero até 2, zero, 1 e 2. E seguinte é isso, nós executamos o Unroll. Eu posso remover isso aqui para que a gente veja um efeito que pode ser observado quando vocês tiverem utilizando essas diretivas, certo? Então, ao rodar o caso um, a gente tem ainda um papá, um pouco mais rante, inclusive, e ao verificar a atualização aqui do Statement File, vou aumentar um pouco, nós temos o seguinte, três versões aqui, da minha execução, certo? Um para cada um daqueles canais. Então, é como se o realite vai se considerando o C, o canal como o loop mais externo. Então, me executando agora com o Computer Roots, para ver o que o lilaio está fazendo com o padrão com essa nosso pipeline. Eu vou recarregar o meu Statement File, e como esperado o que o lilaio está fazendo com o padrão com essa nosso pipeline. Eu vou recarregar o meu Statement File, e como esperado o que o lilaio está fazendo com o padrão, e como esperado o C, o canal, ele está aqui no loop mais externo. Então, ao fazer um roll, a gente estabelece esse extente aqui, com o Bound, certo? E ao fazer um roll, sem o Reorder, ele vai desenrolar essa computação em três grupos diferentes, certo? Então, três grupos por todo a imagem diferente. Vamos, então, remover, e passar a fazer o Reorder junto com as duas outras objetivas. A gente tem um pouco mais rápido que o nosso teste lá inicial, aqueles três loops, certo? Mas ainda não tão rápido contra o paralelo, e também não tão rápido contra o OpenCV. Vamos, então, procedir com o scheduling dessa pipeline, mais antes, passando para verificar a nova estrutura obtida no Statement File. Então, nós temos aqui que temos o loop mais externo em medio de Output pelo X, depois pelo X, e os três canais sendo feito o assign em sequência, uma prois do outro. Eremos, então, passar para o caso dois, que é a aplicação do paralelismo após esse roll, certo? Dessa forma, com o Reorder e o Bound. Nós temos agora um momento na velocidade em comparação, inclusive, acho que é do 0 aqui. Um dia de chegou a 0.29 milicigunos, com o OpenCV aqui já na média, já atingindo valor menor, certo? Inclusive, o pior caso também, tem uma boa diferença. Nós podemos prosseguir com o nosso schedule, fazendo a questão de um splitting e executando o paralelismo a partir desse splitting do Ibsoul, certo? Então, ao invés de paralelizar a var Ibsoul pura, a gente vai fazer um splitting nela antes de aplicar o paralelismo. E, novamente, como antes, eu estou utilizando o VectorSize, obtido com a função NaturalVectorSize do Relage, como a dia para a minha experimentação. Ele falou um valor que eu posso rapidamente experimentar vários fatores dele, como uma guia, certo? O caso aqui estou explicando ele por 8. Então, nós vamos executar aqui o caso 3. É um pouco mais lento que a Aversão do Relage. Pode experimentar, então, em modificar esse VectorSize. O VectorSize obtém um tempo um pouco melhor. Então, um pouco mais rápido, mais ainda assim, não superou o nosso Skyroll 2. Então, observar o Skyroll 4, onde a gente encadeia o splitting com a virtualização, certo? O paralelismo com a virtualização. Nós executamos o nosso roll, fazemos o splitting do Ibsoul e aplicamos o paralelismo na variável mais externa e fazemos o splitting do X e aplicamos a virtualização na variável mais externa, certo? Normalmente, a gente pode experimentar com diversos fatores desse número e variando manualmente os números, certo? Com isso, nós obtemos 0,1 mil segundos. Nós podemos, então, rodar novamente o prototpinho de ser mais e mais. Com o BCV, certo? E, em comparação, nós temos, em metade do tempo, na média com o relate. E, para observar, o que acontece ou se tenta executar essa mesma operação sem o roll, certo? Eu tenho um caso 5 aqui. Então, sem o roll, a gente consegue chegar abaixo do BCV na média, certo? Mas não tão rápido quanto fazendo o roll, inclusive, é também ali no range de metade do tempo em relação a esse schedule sem o roll. A gente pode testar também a reordinação, esse caso assim. E também, um pouco mais rápido, mas, o melhor tempo está na mesma ordem ali do nosso schedule 4. E na média no caso. Então, nós aplicamos o roll para tanto, possibilitar algumas optimizações do nosso código, como também é eliminar o mobs dentro do loop mais interno para o nosso pipeline. Como o leite vai recomendar, eu deixo para vocês tanto a lição de scheduling do relate, como também, o ponto em de relate, definições relacionadas às fanks, certo? Que vai contê as definições do relate, as duas definições do relate para o roll. Muito obrigado pela atenção de vocês e até a próxima. 